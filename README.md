# webCore

---

## Общие

- Методы оптимизации загрузки сайтов и JS приложений
- Анализ производительности (какие есть метрики)
- GraphQL (знать, что это)
- Git Flow
- XSS - как провести атаку, как защититься
- Уметь рассуждать на тему "почему выбрал эту технологию/библиотеку" (fetch vs axios, thunk vs saga, redux vs context)

---

## Верстка (из github)

- Доступность, ARIA аттрибуты
- Микроразметка
- Загрузка ресурсов, async/defer

---

## Верстка (из таблицы)

- Василий Соснин 26.07.2024 - Сдал (Повторить Button)
- Кирилл Аристархов 14.07.24 - сдал (повторить cors, сокеты)
- Александр Лисовой 13.07.24 - Сдал (Повторить OSI модель)
- Денис Каштанов 12.07.24 - сдал (Повторить протоколы, мета-теги, тег picture, схлопывание границ)
- Радмир Шоев 29.07.24 - не сдала (Повторить WebApi)
- Юрий Савко 19.07.2024 – сдал (web- и service-worker и прогр SSR)
- принял Данир Ахметов 26.06.2024 - не сдала(повторить z-index, ,блок Web Technologies и Web API)
- Божко Андрей 22.06.2024 - сдал (Глубже разобраться - PWA, Core Web Witals)
- Лисовой Александр 22.06.2024 - сдал (повторить web Api, web technologies)
- Божко Андрей 16.06.2024 - сдал (Глубже разобраться - PWA, Core Web Witals, MAC адрес, БЭМ)
- 31.05.2024 - Ольга Скворцова - сдал (повторить архитектуры, солид принцип и др., браузерные префиксы)
- 24.05.2024 - Екатерина Венс - не сдала (повторить REST, OSI, Прогрессивный рендеринг (технологии), мультиплексирование
  в HTTP2, доступность веб приложения, валидаторы)
- 23.03.2024 - Кирилл Аристархов - сдал ( повторить трехстороннее рукопожатие, jwt токен, критические этапы рендеринга,
  принципы rest)
- 11.03.24 - Екатерина Венс (не сдал): SSR, CORS, REST, PWA, OSI

---

## Верстка (нужно выучить)

- ***доступность, ARIA аттрибуты***
- ***микроразметка***
- ***загрузка ресурсов, async/defer***
- сокеты
- модель OSI
- протоколы
- мета-теги
- тег picture
- тег button
- схлопывание границ
- Web Technologies
- Web Api
- Core Web Witals
- MAC адрес
- БЭМ
- архитектуры
- принцип SOLID
- браузерные префиксы
- SSR
- CORS
- REST
- PWA
- OSI
- прогрессивный рендеринг
- мультиплексирование в HTTP2
- доступность веб приложения
- валидаторы
- трехстороннее рукопожатие
- jwt токен
- критические этапы рендеринга

---

## Верстка (расписываю)

---

### ***1. доступность, ARIA аттрибуты***

[doka](https://doka.guide/a11y/aria-attrs/)

[mozilla](https://developer.mozilla.org/ru/docs/Web/Accessibility/ARIA/)

ARIA-атрибуты — это группа дополнительных атрибутов из спецификации WAI-ARIA, которая состоит из свойств и состояний.

Состояния (states) описывают состояния элементов и отвечают на вопрос «В каком состоянии сейчас элемент?».

Свойства (properties) нужны для раскрытия дополнительных функций элементов. Отвечают на вопрос «Что ещё делает этот
элемент?».

ARIA-атрибуты поддерживают роли и помогают браузерам и Accessibility API правильно обрабатывать элементы для
вспомогательных технологий. Сами по себе, без CSS и JavaScript, они не изменяют внешний вид и функциональность
элементов.

Общий синтаксис ARIA-атрибутов — aria-атрибут="значение".

aria-describedby="hint"

aria-label="Копировать"

---

### ***2. микроразметка***

https://practicum.yandex.ru/blog/chto-takoe-mikrorazmetka

https://d-element.ru/about/blog/chto-takoe-schema-org

Микроразметка — это добавление в существующий HTML-код страницы элементов языка — тегов и атрибутов, которые помогают
поисковым ботам распознавать контент и показывать пользователям то, что они ищут. Например, по запросу «рецепт
шоколадного печенья», поисковик сразу выдаст список рецептов с фотографиями и необходимой информацией.

Сниппет — это блок информации о странице сайта, которая отображается в результатах поиска. Сниппет состоит из заголовка
и описания страницы, а также может содержать дополнительную информацию о сайте.

С помощью микроразметки в анонс страницы или сниппет можно добавить полезную информацию для посетителей сайта:

- изображения;
- рейтинг товаров;
- контактные данные;
- уникальное торговое предложение (УТП);
- разделы сайта;
- категории товаров;
- описание услуг.

Задачи микроразметки:

- Для аудитории: Возможность сэкономить время и увидеть необходимую информацию сразу, без перехода на сайт.
- Для разработчиков: Способ выделить сниппет в поисковой выдаче, сделать его заметным и доступным.

Виды микроразметки:

- Словари: Набор классов и их свойств, с помощью которых описывают контент страницы. Это язык, доступный для понимания
  алгоритмов поисковых систем. Словарь содержит подробные списки свойств для каждого класса: расписание спектаклей в
  театре, цены на продукты, рейтинги фильмов.
- Синтаксис: это набор правил для использования словаря. Например, он задает инструкцию, как именно специалист может
  использовать и комбинировать слова в «языке». Синтаксис микроразметки регулирует, как и с помощью каких тегов будут
  указываться сущности — части текста, и их свойства, например, на страницах сайта. Самые распространенные стандарты
  синтаксиса: JSON-LD, RDFa, микроданные и микроформаты.

Чаще всего используется три основных вида микроразметки (словари):

- Schema.org: Популярный ресурс для разметки веб-страниц и сообщений электронной почты: такие сервисы, как Яндекс,
  Microsoft, Pinterest и другие, используют его для улучшения пользовательского опыта. Schema.org содержит несколько
  сотен типов микроразметки, и все они подходят для размещения почти любой информации: о компании, эксперте, товаре или
  услуге. Чаще всего используются:
- Open Graph: Разработан специально для соцсетей компанией Facebook. С его помощью можно настроить превью, которое
  формируется во время репоста ссылки на сайт и передачи информации другим интернет-сервисам. Словарём Open Graph для
  микроразметки пользуются ВКонтакте, WhatsApp, Telegram, Viber, LinkedIn, Pinterest, Slack.
- Микроформаты: Это объединённый стандарт синтаксиса и словаря. Менее популярен из-за ограничений: вместе с ним нельзя
  использовать другие словари. С помощью микроформатов можно пересылать сообщения, комментарии, лайки и репосты с одного
  сайта на другой, а также отображать рейтинги на странице результатов поиска. Если нужно больше функций, разработчики
  используют OpenGraph и Schema.org.

title itemprop="headline"
meta itemprop="description" name="description" content="описание_страницы"
meta itemprop="keywords" name="keywords" content="ключевые_слова_для_страницы"

ul itemscope itemtype="http://schema.org/SiteNavigationElement"
li
a itemprop="url" href="ссылка"

itemscope - данный атрибут говорит о том, что тот блок, на котором располагается данный атрибут, - родительский.

itemtype - данный атрибут служит для указания схемы, которую мы будем использовать. В нем мы указываем ссылку на схему,
которую будем использовать в блоке itemtype="https://schema.org/Product".

itemprop - данный атрибут говорит о свойствах сущности.

- itemprop="image" - указывает на то, что это изображение товара.
- itemprop="url" - указывает на то, что это ссылка на товар.
- itemprop="name" - указывает на то, что это имя товара.
- itemprop="description" - указывает на то, что это описание товара.
- itemprop="offers" - указывает на предложение предоставить этот товар — например, предложение продать товар.

https://validator.schema.org

---

### ***3. загрузка ресурсов, async/defer***

https://ru.hexlet.io/blog/posts/rukovodstvo-kak-uvelichit-skorost-zagruzki-stranitsy-so-skriptami-s-pomoschyu-defer-i-async

script async src="script.js"

Если в коде есть оба атрибута, async имеет приоритет и выполняется в первую очередь в современных версиях браузеров. В
старых версиях, напротив, приоритет будет отдан defer.

Оба атрибута стоит использовать только в верхней части страницы (в head)

- async: Сценарий загружается асинхронно, а синтаксический анализатор приостанавливает работу на время его выполнения.
- defer: Скрипт извлекается асинхронно и выполняется только после завершения анализа HTML. Парсинг проходит с той же
  скоростью, как если бы скрипт находился в конце тега body, но в целом выполнение скрипта завершается намного раньше,
  поскольку он загружается параллельно с парсингом HTML. Таким образом этот вариант — наиболее выигрышный с точки зрения
  скорости загрузки страницы.

- async приостанавливает синтаксический анализ страницы, а defer — нет.
- Ни async, ни defer не блокируют рендеринг — этот процесс полностью зависит от кода на странице. Поэтому важно
  убедиться, что сценарии запускаются после события onLoad.
- Скрипты, помеченные как async, выполняются в случайном порядке, тогда как скрипты с defer — в строго определенном.

---

### мета-теги

https://doka-guide.vercel.app/html/meta

Теги meta содержат полезную для поисковиков и браузеров информацию. Информация в метатегах называется метаданными.
Пользователь не видит их содержимое на странице.

Виды метатегов:

- meta charset="UTF-8" — метатег, который задаёт кодировку страницы, не отличается по структуре от обычных
- Остальные метатеги содержат атрибуты name или http-equiv, которые используются в паре с атрибутом content

Атрибуты:

- charset: задаёт кодировку страницы
- name: имя мета-тега, которое также определяет его значение
- http-equiv: атрибут, который может изменять поведение страницы или серверов
- content: основное содержимое метатега, которое используется только с http-equiv и name

Варианты name:

- keywords: ключевые слова, которые помогают поисковикам находить страницу в интернете
- viewport: задаёт параметры окна просмотра в браузере
- description: краткое описание страницы, которое видит пользователь, когда находит сайт в поисковике
- author: имя автора страницы

---

### модель OSI

https://habr.com/ru/companies/serverspace/articles/689704

OSI (Open Systems Interconnection) — это набор правил, который описывает процесс взаимодействия устройств по сети.

По модели процесс передачи данных по сети происходит постепенно от одного уровня к другому. На каждом из них
используются информация с прошлого уровня и определенные протоколы. Главными героями здесь выступают устройства
отправителя и получателя, а также сами передаваемые данные. И как раз процесс обмена информации между устройствами
определяет модель OSI.

- Физический (кабеля): Обмен оптическими, электрическими или радиосигналами между устройствами отправителя и получателя.
- Канальный (коммутаторы): Принимает биты и трансформирует их в кадры (фреймы). Здесь существуют MAC-адреса. Происходит
  еще проверка на ошибки, и исправление информации, а также управление ее передачей.
- Сетевой (роутеры или маршрутизаторы): Маршрутизация трафика. Определяет соответствие между логическим адресом сетевого
  уровня (IP) и физическим адресом устройства (MAC). Здесь пересылаемая информация выступает уже в виде пакетов,
  состоящих из заголовка и поля данных.
- Транспортный: Получает пакеты и передает их по сети.
- Сеансовый: Поддержание сеанса или сессии. Координирует коммуникацию между приложениями и отвечает за установление,
  поддержание и завершение связи, синхронизацию задач и сам обмен информацией.\
- Уровень представления: Подготавливает информацию для последнего и преобразует (сжимает, кодирует, шифрует) их в
  понятный язык для пользователя или машины.
- Прикладной: Отображает данные в понятном конечному пользователю формате.

---

### протоколы

https://university.ylab.io/articles/tpost/v5gsda5r81-osnovnie-veb-protokoli

Протокол передачи данных — набор соглашений интерфейса логического уровня, которые определяют обмен данными между
различными программами.

- IP (Internet Protocol): Основной сетевой протокол, используемый для передачи данных в интернете в форме пакетов.
  Каждое устройство, подключенное к интернету, имеет уникальный IP-адрес, который служит его идентификатором. IP
  обеспечивает маршрутизацию пакетов данных от исходного устройства к целевому на основе этих адресов. В настоящее время
  существуют две версии протокола — IPv4 и IPv6.
- DNS (Domain Name System): Система, преобразующая доменные имена в IP-адреса, позволяя пользователям обращаться к
  веб-сайтам по человекочитаемым адресам, а не по числовым. Благодаря DNS можно ввести доменное имя example.com в
  браузере и попасть на страницу нужного сайта, вместо того чтобы использовать его реальный IP-адрес.
- TCP (Transmission Control Protocol): Надёжный протокол, который обеспечивает установление соединения, гарантированную
  доставку данных и их последовательность.
- UDP (User Datagram Protocol): Напротив, является протоколом без установления соединения, который быстро передает
  данные без гарантии доставки или порядка следования пакетов. В то время как TCP часто используется для веб-трафика и
  других приложений, где важна надежность, UDP предпочтителен для потоковой передачи медиа, онлайн-игр и других
  сценариев, где важна скорость.
- HTTP (Hypertext Transfer Protocol): Основной протокол для передачи контента веб-страниц в интернете. Он служит для
  запроса веб-страниц, изображений и других ресурсов от сервера и получения их браузером или другим клиентом. Несмотря
  на свою универсальность, HTTP не является зашифрованным, что привело к разработке HTTPS — безопасной версии протокола
  с шифрованием данных.
- SSL (Secure Sockets Layer) и TLS (Transport Layer Security): Протоколы криптографической защиты данных,
  обеспечивающие безопасное соединение между клиентом и сервером в интернете. TLS является преемником SSL и
  предоставляет улучшенные механизмы безопасности. Эти протоколы широко используются для защиты веб-трафика, электронной
  почты и других онлайн-сервисов от перехвата и манипуляций.
- HTTPS: Расширение протокола HTTP, обеспечивающее шифрование данных между веб-браузером и сервером. Используя протоколы
  SSL или TLS, HTTPS гарантирует, что данные, передаваемые между пользователем и веб-сайтом, остаются конфиденциальными
  и не подвергаются изменениям. В современном вебе использование HTTPS становится обязательным из-за усиленных
  требований к безопасности и конфиденциальности пользовательских данных
- WebSocket: Протокол, обеспечивающий двунаправленное, постоянное соединение между клиентом и сервером, что позволяет
  отправлять сообщения в обе стороны без повторного установления соединения. В отличие от традиционного HTTP, который
  работает по принципу «запрос-ответ», WebSocket обеспечивает постоянное взаимодействие, идеально подходящее для
  реального времени и интерактивных приложений, таких как онлайн-игры и чаты. Применение WebSocket может существенно
  улучшить производительность и отзывчивость веб-приложений за счет поддержания сессии.

---

### WebSocket

https://folko.gitbook.io/podgotovka-k-sobesedovaniyu/kommunikaciya/web-sockets

Веб-сокеты (Web Sockets) — это передовая технология, которая позволяет создавать интерактивное соединение между
клиентом (браузером) и сервером для обмена сообщениями в режиме реального времени. Веб-сокеты, в отличие от HTTP,
позволяют работать с двунаправленным потоком данных, что делает эту технологию совершенно уникальной.

- http/https: Браузер постоянно спрашивает у сервера, есть ли для него новые сообщения, и получает их.
- Web Sockets: Веб-сокетам для ответа не нужны ваши повторяющиеся запросы. Достаточно выполнить один запрос и ждать
  отклика. Вы можете просто слушать сервер, который будет отправлять вам сообщения по мере готовности.

---

### тег picture

---

### тег button

---

### схлопывание границ

https://habr.com/ru/articles/257327
https://developer.mozilla.org/ru/docs/Web/CSS/CSS_box_model/Mastering_margin_collapsing

Отступы margin-top и margin-bottom иногда объединяются в один, с размером равным наибольшему из них (или размеру одного,
если они равны).

- Соседние элементы
- Родительский и первый/последний дочерние элементы

---

### Web Technologies

https://developer.mozilla.org/ru/docs/Web

- HTML (HyperText Markup Language): язык гипертекстовой разметки, используемый для определения структуры и описания
  содержания веб-страницы в структурированной форме
- CSS (Cascading Style Sheets): каскадные таблицы стилей используются для описания внешнего вида веб-контента

---

### Web Api

https://developer.mozilla.org/ru/docs/Learn/JavaScript/Client-side_web_APIs/Introduction

API (Application Programming Interfaces): Интерфейс прикладного программирования, готовые конструкции языка
программирования, позволяющие разработчику строить сложную функциональность с меньшими усилиями. Они "скрывают" более
сложный код от программиста, обеспечивая простоту использования.

Для JavaScript на стороне клиента, в частности, существует множество API. Они не являются частью языка, а построены с
помощью встроенных функций JavaScript для того, чтобы увеличить ваши возможности при написании кода.

- API браузера встроены в веб-браузер и способны использовать данные браузера и компьютерной среды для осуществления
  более сложных действий с этими данными. К примеру, Web Audio API предоставляет конструкции JavaScript для работы с
  аудио в браузере, например,можно взять звуковую дорожку, изменить её громкость или применить к ней эффекты. На самом
  деле, в браузере выполняется сложный низкоуровневый код (например, на C++ или Rust) для обработки звука, но, как было
  сказано выше, эти детали скрыты благодаря API.
- Сторонние API не встроены в браузер по умолчанию. Такие API и информацию о них обычно необходимо искать в интернете.
  Например, Twitter API позволяет размещать последние твиты (tweets) на вашем веб-сайте. В данном API определён набор
  конструкций, осуществляющих запросы к сервисам Twitter и возвращающих определённые данные.

---

### Core Web Witals

https://habr.com/ru/companies/rambler_and_co/articles/544904
https://developers.google.com/search/docs/appearance/core-web-vitals?hl=ru

Core Web Witals — показатели скорости загрузки страницы.

- Largest Contentful Paint (LCP): Определяет скорость загрузки страницы и ее крупных визуальных элементов. Хороший
  показатель — до 2,5 с.
- First Input Delay (FID): Измеряет интерактивность сайта, то есть насколько быстро он становится доступным к
  взаимодействию после загрузки. Желательным будет показатель до 100 мс.
- Cumulative Layout Shift (CLS): Показывает скорость визуальной стабилизации, то есть насколько быстро всё становится на
  свои места. Идеальным будет показатель меньше 0,1.

---

### MAC адрес

https://habr.com/ru/articles/483670

Media Access Control (MAC) — адрес, который представляет собой уникальную комбинацию цифр и букв длиной 48 символов.
Фактически, это аппаратный номер оборудования (компьютера, сервера, роутера, порта коммутатора, да чего угодно),
который, присваивается сетевой карте устройства еще на фабрике, то есть в момент производства.

IP-адрес — уникальный сетевой адрес узла в компьютерной сети, построенной на основе стека протоколов TCP/IP.

---

### БЭМ

https://ru.bem.info/methodology/quick-start

БЭМ (Блок, Элемент, Модификатор) — компонентный подход к веб-разработке. В его основе лежит принцип разделения
интерфейса на независимые блоки. Он позволяет легко и быстро разрабатывать интерфейсы любой сложности и повторно
использовать существующий код, избегая «Copy-Paste».

- Если фрагмент кода может использоваться повторно и не зависит от реализации других компонентов страницы.
- Если фрагмент кода не может использоваться самостоятельно, без родительской сущности (блока). Исключение составляют
  элементы, реализация которых для упрощения разработки требует разделения на более мелкие части — подэлементы. В
  БЭМ-методологии нельзя создавать элементы элементов. В подобном случае вместо элемента необходимо создавать служебный
  блок.

Блок — Функционально независимый компонент страницы, который может быть повторно использован. В HTML блоки представлены
атрибутом class.

- Название блока характеризует смысл («что это?» — «меню»: menu, «кнопка»: button), а не состояние («какой, как
  выглядит?» — «красный»: red, «большой»: big).
- Блок не должен влиять на свое окружение, т. е. блоку не следует задавать внешнюю геометрию (в виде отступов, границ,
  влияющих на размеры) и позиционирование.
- В CSS по БЭМ также не рекомендуется использовать селекторы по тегам или id.
- Блоки можно вкладывать друг в друга.
- Допустима любая вложенность блоков.

Элемент — Составная часть блока, которая не может использоваться в отрыве от него.

- Название элемента характеризует смысл («что это?» — «пункт»: item, «текст»: text), а не состояние («какой, как
  выглядит?» — «красный»: red, «большой»: big).
- Структура полного имени элемента соответствует схеме: имя-блока__имя-элемента. Имя элемента отделяется от имени блока
  двумя подчеркиваниями (__).
- Элементы можно вкладывать друг в друга.
- Допустима любая вложенность элементов.
- Элемент — всегда часть блока, а не другого элемента. Это означает, что в названии элементов нельзя прописывать
  иерархию вида block__elem1__elem2.
- Элемент — всегда часть блока и не должен использоваться отдельно от него.
- Элемент — необязательный компонент блока. Не у всех блоков должны быть элементы.

Модификатор — Cущность, определяющая внешний вид, состояние или поведение блока либо элемента.

- Название модификатора характеризует внешний вид («какой размер?», «какая тема?» и т. п. — «размер»: size_s, «тема»:
  theme_islands), состояние («чем отличается от прочих?» — «отключен»: disabled, «фокусированный»: focused) и
  поведение («как ведет себя?», «как взаимодействует с пользователем?» — «направление»: directions_left-top).
- Имя модификатора отделяется от имени блока или элемента одним подчеркиванием (_).
- Типы модификаторов: булевый/ключ-значение.

---

### архитектуры

https://learn.microsoft.com/ru-ru/dotnet/architecture/modern-web-apps-azure/common-web-application-

- Монолитное приложение: Полностью замкнуто в контексте поведения. Во время работы оно может взаимодействовать с другими
  службами или хранилищами данных, однако основа его поведения реализуется в собственном процессе, а все приложение
  обычно развертывается как один элемент. Для горизонтального масштабирования такое приложение обычно целиком
  дублируется на нескольких серверах или виртуальных машинах.
- Комплексное приложение: Несколько проектов, каждый из которых размещается в отдельном слое приложения.

---

### принцип SOLID

https://marchenko.gitbook.io/solid

- S: Single Responsibility Principle (Принцип единственной ответственности). Класс должен быть ответственен лишь за
  что-то одно.
- O: Open-Closed Principle (Принцип открытости-закрытости). Программные сущности (классы, модули, функции и т.д.) должны
  быть открыты для расширения, но закрыты для изменения.
- L: Liskov Substitution Principle (Принцип подстановки Барбары Лисков). Наследующий класс должен дополнять (extend —
  расширять), а не изменять базовый.
- I: Interface Segregation Principle (Принцип разделения интерфейса). Много интерфейсов, специально предназначенных для
  клиентов, лучше, чем один интерфейс общего назначения.
- D: Dependency Inversion Principle (Принцип инверсии зависимостей). Зависимость на Абстракциях. Нет зависимости на
  что-то конкретное.

---

### вендорные префиксы

https://doka.guide/css/vendor-prefixes

- -webkit-: Safari (WebKit), Chrome (Blink), Opera 15+ (Blink) и другие браузеры на основе движка WebKit или Blink.
  (WebKit, Blink)
- -moz-: Firefox и браузеры на движке Gecko. (Gecko)
- -o-: Opera 12 и раньше, на движке Presto. (Presto)
- -ms-: Internet Explorer и старый Microsoft Edge 12–18. (Trident, EdgeHTML)

---

### SSR (Server-Side Rendering)

https://habr.com/ru/articles/527310

- Static Site Generation (SSG): Сделать пререндер сайта перед тем как его загрузить на сервер. Очень простое и
  эффективное решение. Отлично подходит для простых веб страничек, без взаимодействия с backend API.
- Server-Side Rendering (SSR): Рендерить контент в рантайме на сервере. При таком подходе мы сможем делать запросы
  backend API и отдавать HTML вместе с необходимым содержимым.

Как работает SSR:

- У нас должен быть сервер, который выполняет наше приложение точно так же, как делал бы это пользователь в браузере.
  Делая запросы на необходимые ресурсы, отображая весь необходимый HTML, наполняя состояние.
- Сервер отдает клиенту наполненный HTML, наполненное состояние, а также отдает все необходимые JS, CSS и прочие
  ресурсы.
- Клиент, получая HTML и ресурсы, синхронизирует состояние и работает с приложением как с обычным Single Page
  Application. При этом важным моментом является то, что состояние должно синхронизироваться.

---

### CORS (Cross-Origin Resource Sharing)

https://developer.mozilla.org/ru/docs/Web/HTTP/CORS
https://doka-guide.vercel.app/tools/cors

Cross-Origin Resource Sharing (CORS) — механизм, использующий дополнительные HTTP-заголовки, чтобы дать возможность
агенту пользователя получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от
того, что сайт использует в данный момент.

CORS расшифровывается как Cross-Origin Resource Sharing. Это механизм браузера, который позволяет определить список
ресурсов, к которым страница может получить доступ. Он необходим для обеспечения безопасности и защиты пользователей от
злоумышленников при использовании HTTP протокола.

Пользователь открывает страницу сайта doka.guide. Страница отправляет запрос к стороннему источнику api.example.com.
Браузер сравнивает origin и понимает, что api.example.com - сторонний origin для нашего сайта, из-за чего блокирует
запрос. Причём запрос может быть заблокирован и в рамках одного домена, например у http://doka.guide
и https://doka.guide origin будет отличаться из-за несовпадения протоколов.

---

### REST (REpresentational State Transfer)

https://habr.com/ru/articles/590679
https://habr.com/ru/articles/483202
https://capsbold.gitbook.io/guide/rest-api

REST (REpresentational State Transfer) — архитектурный стиль взаимодействия компонентов распределённого приложения в
сети.

- Безопасность: HTTP метод считается безопасным, когда вызов этого метода не изменяет состояние данных. Например, когда
  вы извлекаете данные с помощью метода GET, это безопасно, потому что этот метод не обновляет данные на стороне
  сервера.
- Идемпотентность: когда вы получаете один и тот же ответ, сколько раз вы вызываете один и тот же ресурс, он известен
  как идемпотентный. Например, когда вы пытаетесь обновить одни и те же данные на сервере, ответ будет таким же для
  каждого запроса, сделанного с одинаковыми данными.

REST API:

- GET: этот метод является безопасным и идемпотентным. Обычно используется для извлечения информации и не имеет побочных
  эффектов.
- POST (Create): этот метод не является ни безопасным, ни идемпотентным. Этот метод наиболее широко используется для
  создания ресурсов.
- PUT (Update): этот метод является идемпотентным. Вот почему лучше использовать этот метод вместо POST для обновления
  ресурсов. Избегайте использования POST для обновления ресурсов.
- PATCH (Partial modification): этот метод не является идемпотентным. Запрос PUT заменит все содержимое ресурса в
  приложении, в то время как запрос PATCH используется для внесения изменений в часть ресурса, редко используется.
- DELETE: как следует из названия, этот метод используется для удаления ресурсов. Но этот метод не является
  идемпотентным для всех запросов.
- OPTIONS: этот метод не используется для каких-либо манипуляций с ресурсами. Но он полезен, когда клиент не знает
  других методов, поддерживаемых для ресурса, и используя этот метод, клиент может получить различное представление
  ресурса.
- HEAD: этот метод используется для запроса ресурса c сервера. Он очень похож на метод GET, но HEAD должен отправлять
  запрос и получать ответ только в заголовке. Согласно спецификации HTTP, этот метод не должен использовать тело для
  запроса и ответа.

---

### PWA (Progressive Web Applications)

https://habr.com/ru/articles/418923
https://surf.ru/pwa
https://nuancesprog.ru/p/5298

PWA отличаются от мобильной версии сайта тем, что могут работать офлайн, адаптироваться под устройства и выглядеть
практически нативно. Если упростить, то это возможно за счет трех базовых технологий:

- Service Worker: прокси-серверу, который позволяет присылать push-уведомления и сохраняет информацию в кэше. За счет
  этого приложение может работать без доступа к интернету и не требует обновления и перезагрузки в офлайн-режиме в
  отличие от мобильной версии сайта, поскольку оно сохраняет данные каждой сессии.
- HTTPS-запросам: работе со своими ресурсами с помощью HTTPS через браузер аналогично тому, как нативное приложение
  обращается через файловую систему. Браузер выступает в роли виртуальной машины, которая запускает PWA.

---

### прогрессивный рендеринг

https://habr.com/ru/companies/skillfactory/articles/540294/

Рендеринг на стороне клиента (CSR) – это метод, при котором контент рендерится в браузере с помощью JavaScript. Вместо
того чтобы получать весь контент из самого HTML-файла, сервер отправляет HTML с пустым body и тегами script, в которых
содержатся ссылки на JavaScript-бандлы, с помощью которых браузер будет рендерить контент. Теперь давайте посмотрим, как
происходит рендеринг страницы на стороне клиента:

- Когда пользователь переходит на веб-страницу, отправляется запрос на получение HTML-документа.
- Сервер отправляет HTML-код с пустым телом и тегами script для загрузки JS-бандлов.
- Браузер анализирует HTML и шлёт HTTP-запросы для получения JS-бандлов. В это время пользователь видит либо часть
  содержимого HTML, либо пустую страницу, либо индикатор загрузки.
- Только после того как основной JS-бандл получен и отрисован, пользователь видит реальный, значимый контент.

Рендеринг на стороне сервера (SSR) – при рендеринге на стороне сервера HTML-код рендерится на сервере и отправляется
клиенту. Контент, который нам нужно отобразить на экране, становится доступен сразу после анализа HTML; следовательно,
первичный рендеринг контента происходит быстрее, чем у CSR. Теперь давайте разберёмся, как работает SSR:

- Браузер запрашивает HTML с сервера.
- Сервер делает API запросы и рендерит HTML-контент на своей стороне.
- Скомпилированный HTML-код отправляется в браузер.
- Как только браузер загружает и анализирует HTML, веб-приложение становится доступным для конечного пользователя, не
  дожидаясь загрузки JS-бандлов.
- Браузер загружает и запускает JS-бандлы, чтобы сделать страницу интерактивной.

Прогрессивный рендеринг на стороне сервера (PSSR): основан на концепции потоковой передачи HTML. PSSR разбивает страницы
на осмысленные компоненты с помощью разделения кода. Эти части страницы управляются разными скриптами, и теперь у нас
есть возможность сделать гидратацию независимо. Давайте посмотрим, как работает PSSR:

- Браузер запрашивает у сервера HTML-код.
- Сервер делает API запросы и сначала рендерит критический контент, а затем отправляет его клиенту.
- Браузер анализирует HTML и отображает его на экране.
- Сервер рендерит некритический контент и передает его браузеру.
- Затем браузер анализирует и отображает некритичный контент.
- Между тем JS-бандлы загружаются и выполняются в фоновом режиме, а браузер передаёт интерактивность элементам DOM.

PSSR повышает производительность вашего веб-приложения, извлекая и визуализируя компоненты страницы параллельным и
приоритетным образом. Этот подход известен как метод прогрессивной гидратации. Особенности метода прогрессивной
гидратации:

- Рендер компонента не происходит до тех пор, пока он не появится в поле зрения или не понадобится для взаимодействия с
  пользователем.
- Загрузка контента при взаимодействии с пользователем (прокрутка) – намного быстрее, чем при CSR или SSR
- Тестирование показывает, что это может сократить время до появления первого интерактивного элемента.
- Впечатления приятнее даже при медленном соединении.

---

### CRP (Critical Rendering Path) / критические этапы рендеринга

https://habr.com/ru/articles/320430

Браузеру предстоит пройти много шагов, прежде чем HTML-ответ от сервера будет преобразован в пиксели на экране.
Последовательность этих шагов, необходимая для первого отображения страницы, называется «Критический путь рендеринга» (
ориг. Critical Rendering Path).

Существует 6 этапов CRP:

- построение DOM-дерева
- построение CSSOM-дерева
- запуск JavaScript
- создание Render-дерева
- генерация раскладки
- отрисовка

---

### мультиплексирование в HTTP2

https://habr.com/ru/companies/selectel/articles/278167/

Проще говоря, мультиплексирование позволяет вашему браузеру отправлять несколько запросов одновременно по одному
соединению и получать запросы обратно в любом порядке.

Возможно, это самое главное преимущество HTTP/2. В HTTP/1.1 для каждого запроса требуется устанавливать отдельное
TCP-соединение. Мультиплексирование же позволяет браузеру выполнять множество запросов в рамках одного TCP-соединения:

В современных браузерах количество одновременных TCP-соединений ограничено. Поэтому страницы с большим количеством
статического контента загружаются не так быстро, как хотелось бы.

В HTTP/2 благодаря мультиплексированию статические элементы загружаются параллельно, и благодаря этому существенно
улучшается производительность.

---

### доступность веб приложения

https://doka.guide/a11y/chto-takoe-a11y/

Веб-доступность опирается на четыре принципа. Они описывают, какими должны быть веб-интерфейсы и их отдельные элементы и
контент.

- Воспринимаемость (Perceivable): интерфейс можно воспринимать разными органами чувств, например, глазами, ушами и
  кожей.
- Управляемость (Operable): с интерфейсом можно взаимодействовать разными способами, к примеру, с помощью клавиатуры или
  голосом.
- Понятность (Understandable): интерфейс и контент легко понять, ясно как взаимодействовать с интерактивными элементами.
- Устойчивость (Robust): интерфейс соответствует техническим спецификациям и работает на разных устройствах, в разных
  браузерах и с разными вспомогательными технологиями.

---

### валидаторы

https://developer.mozilla.org/ru/docs/Learn/Forms/Form_validation

Существует два типа валидации на стороне клиента, с которыми вы столкнётесь в Интернете:

- Встроенная валидация форм: использует функционал валидации HTML5, который мы неоднократно обсуждали в этом модуле.
  HTML5-валидация обычно не требует большого количества JavaScript-кода и демонстрирует лучшую производительность, но не
  настолько настраиваема, как валидация с помощью JavaScript.
- JavaScript-валидация: кодируется с помощью JavaScript. Она полностью настраиваема, но требует программирования всей
  логики (или использования библиотеки).

---

### трехстороннее рукопожатие

https://habr.com/ru/articles/732794/
https://stormwall.pro/knowledge-base/termin/tcp-handshake

На самом деле все очень просто, TCP является двунаправленной связью, другими словами, обе стороны могут «говорить».
Прежде чем начать «говорить» мы должны обменяться приветствием, в случае с TCP в роли приветствия выступает случайный
номер (ISN), который генерирует один участник соединения и направляет второму участнику, а тот в свою очередь должен
увеличить этот номер на 1 (ISN + 1) и оправить обратно, дабы первый участник убедился, что сообщение получено. То же
самое проделывается и наоборот от второго к первому участнику

---

### jwt токен

https://habr.com/ru/articles/340146/
https://struchkov.dev/blog/ru/what-is-jwt/

- Пользователь отправляет логин и пароль сервису.
- Сервис генерирует случайную строку по какому-то алгоритму.
- Сервис отдает эту строку клиенту и запоминает кому он ее отдал.
- При последующих запросах клиент отправляет куку сервису. Например, клиент хочет получить инфомрацию о себе.
- Сервис знает, что эту строку он отдал такому-то клиенту, поэтому отправляет клиенту его персональные данные.

---
